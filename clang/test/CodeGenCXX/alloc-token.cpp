// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -fsanitize=alloc-token -triple x86_64-linux-gnu -std=c++20 -fexceptions -fcxx-exceptions -emit-llvm -disable-llvm-passes %s -o - | FileCheck %s

#include "../Analysis/Inputs/system-header-simulator-cxx.h"
extern "C" {
void *aligned_alloc(size_t alignment, size_t size) __attribute__((malloc));
void *malloc(size_t size) __attribute__((malloc));
void *calloc(size_t num, size_t size) __attribute__((malloc));
void *realloc(void *ptr, size_t size) __attribute__((malloc));
void *reallocarray(void *ptr, size_t nmemb, size_t size) __attribute__((malloc));
void *memalign(size_t alignment, size_t size) __attribute__((malloc));
void *valloc(size_t size) __attribute__((malloc));
void *pvalloc(size_t size) __attribute__((malloc));
int posix_memalign(void **memptr, size_t alignment, size_t size);

struct __sized_ptr_t {
  void *p;
  size_t n;
};
enum class __hot_cold_t : uint8_t;
__sized_ptr_t __size_returning_new(size_t size);
__sized_ptr_t __size_returning_new_hot_cold(size_t, __hot_cold_t);
__sized_ptr_t __size_returning_new_aligned(size_t, std::align_val_t);
__sized_ptr_t __size_returning_new_aligned_hot_cold(size_t, std::align_val_t,  __hot_cold_t);
}

void *sink; // prevent optimizations from removing the calls

// CHECK-LABEL: define dso_local void @_Z16test_malloc_likev(
// CHECK-SAME: ) #[[ATTR1:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias ptr @malloc(i64 noundef 4) #[[ATTR10:[0-9]+]], !alloc_token [[META2:![0-9]+]]
// CHECK-NEXT:    store ptr [[CALL]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL1:%.*]] = call noalias ptr @calloc(i64 noundef 3, i64 noundef 4) #[[ATTR11:[0-9]+]], !alloc_token [[META2]]
// CHECK-NEXT:    store ptr [[CALL1]], ptr @sink, align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr @sink, align 8
// CHECK-NEXT:    [[CALL2:%.*]] = call noalias ptr @realloc(ptr noundef [[TMP0]], i64 noundef 8) #[[ATTR12:[0-9]+]], !alloc_token [[META3:![0-9]+]]
// CHECK-NEXT:    store ptr [[CALL2]], ptr @sink, align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr @sink, align 8
// CHECK-NEXT:    [[CALL3:%.*]] = call noalias ptr @reallocarray(ptr noundef [[TMP1]], i64 noundef 5, i64 noundef 8), !alloc_token [[META3]]
// CHECK-NEXT:    store ptr [[CALL3]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL4:%.*]] = call noalias align 128 ptr @aligned_alloc(i64 noundef 128, i64 noundef 4) #[[ATTR12]], !alloc_token [[META2]]
// CHECK-NEXT:    store ptr [[CALL4]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL5:%.*]] = call noalias ptr @memalign(i64 noundef 16, i64 noundef 4), !alloc_token [[META2]]
// CHECK-NEXT:    store ptr [[CALL5]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL6:%.*]] = call noalias ptr @valloc(i64 noundef 4), !alloc_token [[META2]]
// CHECK-NEXT:    store ptr [[CALL6]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL7:%.*]] = call noalias ptr @pvalloc(i64 noundef 4), !alloc_token [[META2]]
// CHECK-NEXT:    store ptr [[CALL7]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL8:%.*]] = call i32 @posix_memalign(ptr noundef @sink, i64 noundef 64, i64 noundef 4)
// CHECK-NEXT:    ret void
//
void test_malloc_like() {
  sink = malloc(sizeof(int));
  sink = calloc(3, sizeof(int));
  sink = realloc(sink, sizeof(long));
  sink = reallocarray(sink, 5, sizeof(long));
  sink = aligned_alloc(128, sizeof(int));
  sink = memalign(16, sizeof(int));
  sink = valloc(sizeof(int));
  sink = pvalloc(sizeof(int));
  posix_memalign(&sink, 64, sizeof(int)); // FIXME: support posix_memalign
}

class ForwardDecl;

// CHECK-LABEL: define dso_local void @_Z21test_malloc_like_castv(
// CHECK-SAME: ) #[[ATTR1]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias ptr @malloc(i64 noundef 64) #[[ATTR10]], !alloc_token [[META2]]
// CHECK-NEXT:    store ptr [[CALL]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL1:%.*]] = call noalias ptr @malloc(i64 noundef 64) #[[ATTR10]], !alloc_token [[META2]]
// CHECK-NEXT:    store ptr [[CALL1]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL2:%.*]] = call noalias ptr @malloc(i64 noundef 64) #[[ATTR10]]
// CHECK-NEXT:    store ptr [[CALL2]], ptr @sink, align 8
// CHECK-NEXT:    ret void
//
void test_malloc_like_cast() {
  sink = (int *)malloc(64);
  sink = reinterpret_cast<int *>(malloc(64));

  // Always fails to assign token ID for incomplete types.
  sink = reinterpret_cast<ForwardDecl *>(malloc(64));
}

// CHECK-LABEL: define dso_local void @_Z17test_operator_newv(
// CHECK-SAME: ) #[[ATTR1]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 4) #[[ATTR13:[0-9]+]], !alloc_token [[META2]]
// CHECK-NEXT:    store ptr [[CALL]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL1:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 4) #[[ATTR10]], !alloc_token [[META2]]
// CHECK-NEXT:    store ptr [[CALL1]], ptr @sink, align 8
// CHECK-NEXT:    ret void
//
void test_operator_new() {
  sink = __builtin_operator_new(sizeof(int));
  sink = ::operator new(sizeof(int));
}

// CHECK-LABEL: define dso_local void @_Z25test_operator_new_nothrowv(
// CHECK-SAME: ) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef ptr @_ZnwmRKSt9nothrow_t(i64 noundef 4, ptr noundef nonnull align 1 dereferenceable(1) @_ZSt7nothrow) #[[ATTR14:[0-9]+]], !alloc_token [[META2]]
// CHECK-NEXT:    store ptr [[CALL]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL1:%.*]] = call noalias noundef ptr @_ZnwmRKSt9nothrow_t(i64 noundef 4, ptr noundef nonnull align 1 dereferenceable(1) @_ZSt7nothrow) #[[ATTR15:[0-9]+]], !alloc_token [[META2]]
// CHECK-NEXT:    store ptr [[CALL1]], ptr @sink, align 8
// CHECK-NEXT:    ret void
//
void test_operator_new_nothrow() {
  sink = __builtin_operator_new(sizeof(int), std::nothrow);
  sink = ::operator new(sizeof(int), std::nothrow);
}

// CHECK-LABEL: define dso_local noundef ptr @_Z8test_newv(
// CHECK-SAME: ) #[[ATTR1]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 4) #[[ATTR13]], !alloc_token [[META2]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
int *test_new() {
  return new int;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z14test_new_arrayv(
// CHECK-SAME: ) #[[ATTR1]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znam(i64 noundef 40) #[[ATTR13]], !alloc_token [[META2]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
int *test_new_array() {
  return new int[10];
}

// CHECK-LABEL: define dso_local noundef ptr @_Z16test_new_nothrowv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef ptr @_ZnwmRKSt9nothrow_t(i64 noundef 4, ptr noundef nonnull align 1 dereferenceable(1) @_ZSt7nothrow) #[[ATTR14]], !alloc_token [[META2]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
int *test_new_nothrow() {
  return new (std::nothrow) int;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z22test_new_array_nothrowv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef ptr @_ZnamRKSt9nothrow_t(i64 noundef 40, ptr noundef nonnull align 1 dereferenceable(1) @_ZSt7nothrow) #[[ATTR14]], !alloc_token [[META2]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
int *test_new_array_nothrow() {
  return new (std::nothrow) int[10];
}

// CHECK-LABEL: define dso_local void @_Z23test_size_returning_newv(
// CHECK-SAME: ) #[[ATTR1]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[REF_TMP:%.*]] = alloca [[STRUCT___SIZED_PTR_T:%.*]], align 8
// CHECK-NEXT:    [[REF_TMP1:%.*]] = alloca [[STRUCT___SIZED_PTR_T]], align 8
// CHECK-NEXT:    [[REF_TMP4:%.*]] = alloca [[STRUCT___SIZED_PTR_T]], align 8
// CHECK-NEXT:    [[REF_TMP7:%.*]] = alloca [[STRUCT___SIZED_PTR_T]], align 8
// CHECK-NEXT:    [[CALL:%.*]] = call { ptr, i64 } @__size_returning_new(i64 noundef 8)
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds nuw { ptr, i64 }, ptr [[REF_TMP]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i64 } [[CALL]], 0
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[TMP0]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds nuw { ptr, i64 }, ptr [[REF_TMP]], i32 0, i32 1
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, i64 } [[CALL]], 1
// CHECK-NEXT:    store i64 [[TMP3]], ptr [[TMP2]], align 8
// CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds nuw [[STRUCT___SIZED_PTR_T]], ptr [[REF_TMP]], i32 0, i32 0
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[P]], align 8
// CHECK-NEXT:    store ptr [[TMP4]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL2:%.*]] = call { ptr, i64 } @__size_returning_new_hot_cold(i64 noundef 8, i8 noundef zeroext 1)
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds nuw { ptr, i64 }, ptr [[REF_TMP1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { ptr, i64 } [[CALL2]], 0
// CHECK-NEXT:    store ptr [[TMP6]], ptr [[TMP5]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds nuw { ptr, i64 }, ptr [[REF_TMP1]], i32 0, i32 1
// CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { ptr, i64 } [[CALL2]], 1
// CHECK-NEXT:    store i64 [[TMP8]], ptr [[TMP7]], align 8
// CHECK-NEXT:    [[P3:%.*]] = getelementptr inbounds nuw [[STRUCT___SIZED_PTR_T]], ptr [[REF_TMP1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP9:%.*]] = load ptr, ptr [[P3]], align 8
// CHECK-NEXT:    store ptr [[TMP9]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL5:%.*]] = call { ptr, i64 } @__size_returning_new_aligned(i64 noundef 8, i64 noundef 32)
// CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds nuw { ptr, i64 }, ptr [[REF_TMP4]], i32 0, i32 0
// CHECK-NEXT:    [[TMP11:%.*]] = extractvalue { ptr, i64 } [[CALL5]], 0
// CHECK-NEXT:    store ptr [[TMP11]], ptr [[TMP10]], align 8
// CHECK-NEXT:    [[TMP12:%.*]] = getelementptr inbounds nuw { ptr, i64 }, ptr [[REF_TMP4]], i32 0, i32 1
// CHECK-NEXT:    [[TMP13:%.*]] = extractvalue { ptr, i64 } [[CALL5]], 1
// CHECK-NEXT:    store i64 [[TMP13]], ptr [[TMP12]], align 8
// CHECK-NEXT:    [[P6:%.*]] = getelementptr inbounds nuw [[STRUCT___SIZED_PTR_T]], ptr [[REF_TMP4]], i32 0, i32 0
// CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[P6]], align 8
// CHECK-NEXT:    store ptr [[TMP14]], ptr @sink, align 8
// CHECK-NEXT:    [[CALL8:%.*]] = call { ptr, i64 } @__size_returning_new_aligned_hot_cold(i64 noundef 8, i64 noundef 32, i8 noundef zeroext 1)
// CHECK-NEXT:    [[TMP15:%.*]] = getelementptr inbounds nuw { ptr, i64 }, ptr [[REF_TMP7]], i32 0, i32 0
// CHECK-NEXT:    [[TMP16:%.*]] = extractvalue { ptr, i64 } [[CALL8]], 0
// CHECK-NEXT:    store ptr [[TMP16]], ptr [[TMP15]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = getelementptr inbounds nuw { ptr, i64 }, ptr [[REF_TMP7]], i32 0, i32 1
// CHECK-NEXT:    [[TMP18:%.*]] = extractvalue { ptr, i64 } [[CALL8]], 1
// CHECK-NEXT:    store i64 [[TMP18]], ptr [[TMP17]], align 8
// CHECK-NEXT:    [[P9:%.*]] = getelementptr inbounds nuw [[STRUCT___SIZED_PTR_T]], ptr [[REF_TMP7]], i32 0, i32 0
// CHECK-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[P9]], align 8
// CHECK-NEXT:    store ptr [[TMP19]], ptr @sink, align 8
// CHECK-NEXT:    ret void
//
void test_size_returning_new() {
  // FIXME: Support __size_returning_new variants.
  sink = __size_returning_new(sizeof(long)).p;
  sink = __size_returning_new_hot_cold(sizeof(long), __hot_cold_t{1}).p;
  sink = __size_returning_new_aligned(sizeof(long), std::align_val_t{32}).p;
  sink = __size_returning_new_aligned_hot_cold(sizeof(long), std::align_val_t{32}, __hot_cold_t{1}).p;
}

class TestClass {
public:
  virtual void Foo();
  virtual ~TestClass();
  int data[16];
};

void may_throw();

// CHECK-LABEL: define dso_local noundef ptr @_Z27test_exception_handling_newv(
// CHECK-SAME: ) #[[ATTR1]] personality ptr @__gxx_personality_v0 {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[OBJ:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[EXN_SLOT:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[EHSELECTOR_SLOT:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[CALL:%.*]] = invoke noalias noundef nonnull ptr @_Znwm(i64 noundef 72) #[[ATTR13]]
// CHECK-NEXT:            to label %[[INVOKE_CONT:.*]] unwind label %[[LPAD:.*]], !alloc_token [[META4:![0-9]+]]
// CHECK:       [[INVOKE_CONT]]:
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[CALL]], i8 0, i64 72, i1 false)
// CHECK-NEXT:    call void @_ZN9TestClassC1Ev(ptr noundef nonnull align 8 dereferenceable(72) [[CALL]]) #[[ATTR16:[0-9]+]]
// CHECK-NEXT:    store ptr [[CALL]], ptr [[OBJ]], align 8
// CHECK-NEXT:    invoke void @_Z9may_throwv()
// CHECK-NEXT:            to label %[[INVOKE_CONT1:.*]] unwind label %[[LPAD]]
// CHECK:       [[INVOKE_CONT1]]:
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[OBJ]], align 8
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[RETVAL]], align 8
// CHECK-NEXT:    br label %[[RETURN:.*]]
// CHECK:       [[LPAD]]:
// CHECK-NEXT:    [[TMP1:%.*]] = landingpad { ptr, i32 }
// CHECK-NEXT:            catch ptr null
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, i32 } [[TMP1]], 0
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[EXN_SLOT]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, i32 } [[TMP1]], 1
// CHECK-NEXT:    store i32 [[TMP3]], ptr [[EHSELECTOR_SLOT]], align 4
// CHECK-NEXT:    br label %[[CATCH:.*]]
// CHECK:       [[CATCH]]:
// CHECK-NEXT:    [[EXN:%.*]] = load ptr, ptr [[EXN_SLOT]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = call ptr @__cxa_begin_catch(ptr [[EXN]]) #[[ATTR16]]
// CHECK-NEXT:    store ptr null, ptr [[RETVAL]], align 8
// CHECK-NEXT:    call void @__cxa_end_catch()
// CHECK-NEXT:    br label %[[RETURN]]
// CHECK:       [[TRY_CONT:.*:]]
// CHECK-NEXT:    call void @llvm.trap()
// CHECK-NEXT:    unreachable
// CHECK:       [[RETURN]]:
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[RETVAL]], align 8
// CHECK-NEXT:    ret ptr [[TMP5]]
//
TestClass *test_exception_handling_new() {
  try {
    TestClass *obj = new TestClass();
    may_throw();
    return obj;
  } catch (...) {
    return nullptr;
  }
}

// CHECK-LABEL: define dso_local noundef ptr @_Z14test_new_classv(
// CHECK-SAME: ) #[[ATTR1]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[OBJ:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 72) #[[ATTR13]], !alloc_token [[META4]]
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[CALL]], i8 0, i64 72, i1 false)
// CHECK-NEXT:    call void @_ZN9TestClassC1Ev(ptr noundef nonnull align 8 dereferenceable(72) [[CALL]]) #[[ATTR16]]
// CHECK-NEXT:    store ptr [[CALL]], ptr [[OBJ]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[OBJ]], align 8
// CHECK-NEXT:    [[DATA:%.*]] = getelementptr inbounds nuw [[CLASS_TESTCLASS:%.*]], ptr [[TMP0]], i32 0, i32 1
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [16 x i32], ptr [[DATA]], i64 0, i64 0
// CHECK-NEXT:    store i32 42, ptr [[ARRAYIDX]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[OBJ]], align 8
// CHECK-NEXT:    ret ptr [[TMP1]]
//
TestClass *test_new_class() {
  TestClass *obj = new TestClass();
  obj->data[0] = 42;
  return obj;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z20test_new_class_arrayv(
// CHECK-SAME: ) #[[ATTR1]] {
// CHECK-NEXT:  [[ENTRY:.*]]:
// CHECK-NEXT:    [[ARR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znam(i64 noundef 728) #[[ATTR13]], !alloc_token [[META4]]
// CHECK-NEXT:    store i64 10, ptr [[CALL]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[CALL]], i64 8
// CHECK-NEXT:    [[ARRAYCTOR_END:%.*]] = getelementptr inbounds [[CLASS_TESTCLASS:%.*]], ptr [[TMP0]], i64 10
// CHECK-NEXT:    br label %[[ARRAYCTOR_LOOP:.*]]
// CHECK:       [[ARRAYCTOR_LOOP]]:
// CHECK-NEXT:    [[ARRAYCTOR_CUR:%.*]] = phi ptr [ [[TMP0]], %[[ENTRY]] ], [ [[ARRAYCTOR_NEXT:%.*]], %[[ARRAYCTOR_LOOP]] ]
// CHECK-NEXT:    call void @_ZN9TestClassC1Ev(ptr noundef nonnull align 8 dereferenceable(72) [[ARRAYCTOR_CUR]]) #[[ATTR16]]
// CHECK-NEXT:    [[ARRAYCTOR_NEXT]] = getelementptr inbounds [[CLASS_TESTCLASS]], ptr [[ARRAYCTOR_CUR]], i64 1
// CHECK-NEXT:    [[ARRAYCTOR_DONE:%.*]] = icmp eq ptr [[ARRAYCTOR_NEXT]], [[ARRAYCTOR_END]]
// CHECK-NEXT:    br i1 [[ARRAYCTOR_DONE]], label %[[ARRAYCTOR_CONT:.*]], label %[[ARRAYCTOR_LOOP]]
// CHECK:       [[ARRAYCTOR_CONT]]:
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[ARR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[ARR]], align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [[CLASS_TESTCLASS]], ptr [[TMP1]], i64 0
// CHECK-NEXT:    [[DATA:%.*]] = getelementptr inbounds nuw [[CLASS_TESTCLASS]], ptr [[ARRAYIDX]], i32 0, i32 1
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds [16 x i32], ptr [[DATA]], i64 0, i64 0
// CHECK-NEXT:    store i32 123, ptr [[ARRAYIDX1]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[ARR]], align 8
// CHECK-NEXT:    ret ptr [[TMP2]]
//
TestClass *test_new_class_array() {
  TestClass* arr = new TestClass[10];
  arr[0].data[0] = 123;
  return arr;
}

// We should not be touching malloc-attributed non-libcall functions: there
// might be an arbitrary number of these, and a compatible allocator will only
// implement standard allocation functions.
void *nonstandard_malloc(size_t size) __attribute__((malloc));
// CHECK-LABEL: define dso_local noundef ptr @_Z22test_nonlibcall_mallocv(
// CHECK-SAME: ) #[[ATTR1]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef ptr @_Z18nonstandard_mallocm(i64 noundef 4), !alloc_token [[META2]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
void *test_nonlibcall_malloc() {
  return nonstandard_malloc(sizeof(int));
}
//.
// CHECK: [[META2]] = !{!"int", i1 false}
// CHECK: [[META3]] = !{!"long", i1 false}
// CHECK: [[META4]] = !{!"TestClass", i1 true}
//.
