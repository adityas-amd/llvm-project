// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -fsanitize=alloc-token -triple x86_64-linux-gnu -std=c++20 -emit-llvm -disable-llvm-passes %s -o - | FileCheck %s

#include "../Analysis/Inputs/system-header-simulator-cxx.h"

typedef __UINTPTR_TYPE__ uintptr_t;

extern "C" {
void *malloc(size_t size) __attribute__((malloc));
}

void *sink; // prevent optimizations from removing the calls

// CHECK-LABEL: define dso_local noundef ptr @_Z15test_malloc_intv(
// CHECK-SAME: ) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noalias ptr @malloc(i64 noundef 4) #[[ATTR4:[0-9]+]], !alloc_token [[META2:![0-9]+]]
// CHECK-NEXT:    store ptr [[CALL]], ptr [[A]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A]], align 8
// CHECK-NEXT:    store i32 42, ptr [[TMP0]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[A]], align 8
// CHECK-NEXT:    ret ptr [[TMP1]]
//
void *test_malloc_int() {
  int *a = (int *)malloc(sizeof(int));
  *a = 42;
  return a;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z15test_malloc_ptrv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noalias ptr @malloc(i64 noundef 8) #[[ATTR4]], !alloc_token [[META3:![0-9]+]]
// CHECK-NEXT:    store ptr [[CALL]], ptr [[A]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A]], align 8
// CHECK-NEXT:    store ptr null, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[A]], align 8
// CHECK-NEXT:    ret ptr [[TMP1]]
//
int **test_malloc_ptr() {
  int **a = (int **)malloc(sizeof(int*));
  *a = nullptr;
  return a;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z12test_new_intv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 4) #[[ATTR5:[0-9]+]], !alloc_token [[META2]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
int *test_new_int() {
  return new int;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z20test_new_ulong_arrayv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znam(i64 noundef 80) #[[ATTR5]], !alloc_token [[META4:![0-9]+]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
unsigned long *test_new_ulong_array() {
  return new unsigned long[10];
}

// CHECK-LABEL: define dso_local noundef ptr @_Z12test_new_ptrv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 8) #[[ATTR5]], !alloc_token [[META3]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
int **test_new_ptr() {
  return new int*;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z18test_new_ptr_arrayv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znam(i64 noundef 80) #[[ATTR5]], !alloc_token [[META3]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
int **test_new_ptr_array() {
  return new int*[10];
}

struct ContainsPtr {
  int a;
  char *buf;
};

// CHECK-LABEL: define dso_local noundef ptr @_Z27test_malloc_struct_with_ptrv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias ptr @malloc(i64 noundef 16) #[[ATTR4]], !alloc_token [[META5:![0-9]+]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
void *test_malloc_struct_with_ptr() {
  return malloc(sizeof(ContainsPtr));
}

// CHECK-LABEL: define dso_local noundef ptr @_Z33test_malloc_struct_array_with_ptrv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias ptr @malloc(i64 noundef 160) #[[ATTR4]], !alloc_token [[META5]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
void *test_malloc_struct_array_with_ptr() {
  return malloc(10 * sizeof(ContainsPtr));
}

// CHECK-LABEL: define dso_local noundef ptr @_Z31test_malloc_with_ptr_sizeof_vari(
// CHECK-SAME: i32 noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[SIZE:%.*]] = alloca i64, align 8
// CHECK-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    store i64 16, ptr [[SIZE]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[SIZE]], align 8
// CHECK-NEXT:    [[MUL:%.*]] = mul i64 [[TMP1]], [[CONV]]
// CHECK-NEXT:    store i64 [[MUL]], ptr [[SIZE]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[SIZE]], align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noalias ptr @malloc(i64 noundef [[TMP2]]) #[[ATTR4]], !alloc_token [[META5]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
void *test_malloc_with_ptr_sizeof_var(int x) {
  unsigned long size = sizeof(ContainsPtr);
  size *= x;
  return malloc(size);
}

// CHECK-LABEL: define dso_local noundef ptr @_Z29test_malloc_with_ptr_castonlyv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias ptr @malloc(i64 noundef 4096) #[[ATTR4]], !alloc_token [[META5]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
ContainsPtr *test_malloc_with_ptr_castonly() {
  return (ContainsPtr *)malloc(4096);
}

// CHECK-LABEL: define dso_local noundef ptr @_Z32test_operatornew_struct_with_ptrv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[C:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 16) #[[ATTR5]], !alloc_token [[META5]]
// CHECK-NEXT:    store ptr [[CALL]], ptr [[C]], align 8
// CHECK-NEXT:    [[CALL1:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 16) #[[ATTR4]], !alloc_token [[META5]]
// CHECK-NEXT:    store ptr [[CALL1]], ptr @sink, align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[C]], align 8
// CHECK-NEXT:    ret ptr [[TMP0]]
//
ContainsPtr *test_operatornew_struct_with_ptr() {
  ContainsPtr *c = (ContainsPtr *)__builtin_operator_new(sizeof(ContainsPtr));
  sink = ::operator new(sizeof(ContainsPtr));
  return c;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z38test_operatornew_struct_array_with_ptrv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[C:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 160) #[[ATTR5]], !alloc_token [[META5]]
// CHECK-NEXT:    store ptr [[CALL]], ptr [[C]], align 8
// CHECK-NEXT:    [[CALL1:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 160) #[[ATTR4]], !alloc_token [[META5]]
// CHECK-NEXT:    store ptr [[CALL1]], ptr @sink, align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[C]], align 8
// CHECK-NEXT:    ret ptr [[TMP0]]
//
ContainsPtr *test_operatornew_struct_array_with_ptr() {
  ContainsPtr *c = (ContainsPtr *)__builtin_operator_new(10 * sizeof(ContainsPtr));
  sink = ::operator new(10 * sizeof(ContainsPtr));
  return c;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z33test_operatornew_struct_with_ptr2v(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[C:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 16) #[[ATTR5]], !alloc_token [[META5]]
// CHECK-NEXT:    store ptr [[CALL]], ptr [[C]], align 8
// CHECK-NEXT:    [[CALL1:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 16) #[[ATTR4]], !alloc_token [[META5]]
// CHECK-NEXT:    store ptr [[CALL1]], ptr @sink, align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[C]], align 8
// CHECK-NEXT:    ret ptr [[TMP0]]
//
ContainsPtr *test_operatornew_struct_with_ptr2() {
  ContainsPtr *c = (ContainsPtr *)__builtin_operator_new(sizeof(*c));
  sink = ::operator new(sizeof(*c));
  return c;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z39test_operatornew_struct_array_with_ptr2v(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[C:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 160) #[[ATTR5]], !alloc_token [[META5]]
// CHECK-NEXT:    store ptr [[CALL]], ptr [[C]], align 8
// CHECK-NEXT:    [[CALL1:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 160) #[[ATTR4]], !alloc_token [[META5]]
// CHECK-NEXT:    store ptr [[CALL1]], ptr @sink, align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[C]], align 8
// CHECK-NEXT:    ret ptr [[TMP0]]
//
ContainsPtr *test_operatornew_struct_array_with_ptr2() {
  ContainsPtr *c = (ContainsPtr *)__builtin_operator_new(10 * sizeof(*c));
  sink = ::operator new(10 * sizeof(*c));
  return c;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z24test_new_struct_with_ptrv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 16) #[[ATTR5]], !alloc_token [[META5]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
ContainsPtr *test_new_struct_with_ptr() {
  return new ContainsPtr;
}

// CHECK-LABEL: define dso_local noundef ptr @_Z30test_new_struct_array_with_ptrv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znam(i64 noundef 160) #[[ATTR5]], !alloc_token [[META5]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
ContainsPtr *test_new_struct_array_with_ptr() {
  return new ContainsPtr[10];
}

class TestClass {
public:
  void Foo();
  ~TestClass();
  int data[16];
};

// CHECK-LABEL: define dso_local noundef ptr @_Z14test_new_classv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 64) #[[ATTR5]], !alloc_token [[META6:![0-9]+]]
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[CALL]], i8 0, i64 64, i1 false)
// CHECK-NEXT:    ret ptr [[CALL]]
//
TestClass *test_new_class() {
  return new TestClass();
}

// CHECK-LABEL: define dso_local noundef ptr @_Z20test_new_class_arrayv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znam(i64 noundef 648) #[[ATTR5]], !alloc_token [[META6]]
// CHECK-NEXT:    store i64 10, ptr [[CALL]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[CALL]], i64 8
// CHECK-NEXT:    ret ptr [[TMP0]]
//
TestClass *test_new_class_array() {
  return new TestClass[10];
}

// Test that we detect that virtual classes have implicit vtable pointer.
class VirtualTestClass {
public:
  virtual void Foo();
  virtual ~VirtualTestClass();
  int data[16];
};

// CHECK-LABEL: define dso_local noundef ptr @_Z22test_new_virtual_classv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 72) #[[ATTR5]], !alloc_token [[META7:![0-9]+]]
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[CALL]], i8 0, i64 72, i1 false)
// CHECK-NEXT:    call void @_ZN16VirtualTestClassC1Ev(ptr noundef nonnull align 8 dereferenceable(72) [[CALL]]) #[[ATTR6:[0-9]+]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
VirtualTestClass *test_new_virtual_class() {
  return new VirtualTestClass();
}

// CHECK-LABEL: define dso_local noundef ptr @_Z28test_new_virtual_class_arrayv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*]]:
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znam(i64 noundef 728) #[[ATTR5]], !alloc_token [[META7]]
// CHECK-NEXT:    store i64 10, ptr [[CALL]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[CALL]], i64 8
// CHECK-NEXT:    [[ARRAYCTOR_END:%.*]] = getelementptr inbounds [[CLASS_VIRTUALTESTCLASS:%.*]], ptr [[TMP0]], i64 10
// CHECK-NEXT:    br label %[[ARRAYCTOR_LOOP:.*]]
// CHECK:       [[ARRAYCTOR_LOOP]]:
// CHECK-NEXT:    [[ARRAYCTOR_CUR:%.*]] = phi ptr [ [[TMP0]], %[[ENTRY]] ], [ [[ARRAYCTOR_NEXT:%.*]], %[[ARRAYCTOR_LOOP]] ]
// CHECK-NEXT:    call void @_ZN16VirtualTestClassC1Ev(ptr noundef nonnull align 8 dereferenceable(72) [[ARRAYCTOR_CUR]]) #[[ATTR6]]
// CHECK-NEXT:    [[ARRAYCTOR_NEXT]] = getelementptr inbounds [[CLASS_VIRTUALTESTCLASS]], ptr [[ARRAYCTOR_CUR]], i64 1
// CHECK-NEXT:    [[ARRAYCTOR_DONE:%.*]] = icmp eq ptr [[ARRAYCTOR_NEXT]], [[ARRAYCTOR_END]]
// CHECK-NEXT:    br i1 [[ARRAYCTOR_DONE]], label %[[ARRAYCTOR_CONT:.*]], label %[[ARRAYCTOR_LOOP]]
// CHECK:       [[ARRAYCTOR_CONT]]:
// CHECK-NEXT:    ret ptr [[TMP0]]
//
VirtualTestClass *test_new_virtual_class_array() {
  return new VirtualTestClass[10];
}

// uintptr_t is treated as a pointer.
struct MyStructUintptr {
  int a;
  uintptr_t ptr;
};

// CHECK-LABEL: define dso_local noundef ptr @_Z18test_uintptr_isptrv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 16) #[[ATTR5]], !alloc_token [[META8:![0-9]+]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
MyStructUintptr *test_uintptr_isptr() {
  return new MyStructUintptr;
}

using uptr = uintptr_t;
// CHECK-LABEL: define dso_local noundef ptr @_Z19test_uintptr_isptr2v(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef nonnull ptr @_Znwm(i64 noundef 8) #[[ATTR5]], !alloc_token [[META9:![0-9]+]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
uptr *test_uintptr_isptr2() {
  return new uptr;
}
//.
// CHECK: [[META2]] = !{!"int", i1 false}
// CHECK: [[META3]] = !{!"int *", i1 true}
// CHECK: [[META4]] = !{!"unsigned long", i1 false}
// CHECK: [[META5]] = !{!"ContainsPtr", i1 true}
// CHECK: [[META6]] = !{!"TestClass", i1 false}
// CHECK: [[META7]] = !{!"VirtualTestClass", i1 true}
// CHECK: [[META8]] = !{!"MyStructUintptr", i1 true}
// CHECK: [[META9]] = !{!"unsigned long", i1 true}
//.
